# -*- coding: utf-8 -*-
"""02_Algorithms_00_Time-Evolution.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Y7iD0QibXqSE1pAHNhGv7vqyEe_Ytqc2
"""

!pip install qiskit
!pip install qiskit_aer
!pip install pylatexenc
!pip install qiskit_ibm_runtime

from qiskit.quantum_info import SparsePauliOp

def mixed_field_ising_hamiltonian(J, h, g, num_qubits):
    """Constructs the mixed-field Ising Hamiltonian as a SparsePauliOp."""
    # Hamiltonian initialization
    H_terms = []
    H_coeffs = []

    # Add nearest-neighbor ZZ interactions
    for i in range(num_qubits - 1):  # Use num_qubits - 1 for open boundary conditions
        H_terms.append("I" * (num_qubits - i - 2) + "ZZ" + "I" * i)
        H_coeffs.append(-J)

    # Add transverse field terms
    for i in range(num_qubits):
        H_terms.append("I" * (num_qubits - i - 1) + "X" + "I" * i)
        H_coeffs.append(-h)

    # Add longitudinal field terms
    for i in range(num_qubits):
        H_terms.append("I" * (num_qubits - i - 1) + "Z" + "I" * i)
        H_coeffs.append(-g)

    return SparsePauliOp(H_terms, H_coeffs)

from qiskit import QuantumCircuit, transpile
from qiskit.circuit import Parameter
from qiskit.quantum_info import Operator
import numpy as np
import matplotlib.pyplot as plt
from scipy.linalg import expm

def trotterized_time_evolution_circuit(J, h, g, num_qubits, time, trotter_steps, order=1):
    """
    Constructs a circuit for the Trotterized time evolution of the mixed-field Ising model, defined as
    H = \sum_{<ij>} J Z_i Z_j + \sum_i h X_i + \sum_j g Z_i

    Parameters:
    - J: Coupling strength
    - h: Transverse field strength
    - g: Longitudinal field strength
    - num_qubits: Number of qubits (spins)
    - time: Total evolution time
    - trotter_steps: Number of Trotter steps
    - order: Order of Trotterization (0, 1, 2), where 0 is for exact evolution

    Returns:
    - A Qiskit QuantumCircuit for the specified time evolution.
    """
    # Time step for Trotterization
    if time > 0:
      dt = time / trotter_steps
    else:
      dt = 0

    # Initialize circuit
    circuit = QuantumCircuit(num_qubits)

    if order == 0:
        H_matrix = mixed_field_ising_hamiltonian(J, h, g, num_qubits)
        exp_iHt = expm(-1j * H_matrix * time)
        circuit.unitary(Operator(exp_iHt), list(range(num_qubits)), label="exp(-iHt)")
    elif order == 1:
        for step in range(trotter_steps):
            # ZZ coupling
            for i in range(num_qubits - 1):
                circuit.rzz(2 * J * dt, i, i + 1)
            # Transverse field
            for i in range(num_qubits):
                circuit.rx(2 * h * dt, i)
            # Longitudinal field
            for i in range(num_qubits):
                circuit.rz(2 * g * dt, i)
    elif order == 2:
        for step in range(trotter_steps):
            # Apply the first half of H_X and H_Z
            for i in range(num_qubits):
                circuit.rz(g * dt, i)  # First half of H_Z
                circuit.rx(h * dt, i)  # First half of H_X

            # Apply H_{ZZ}
            for i in range(num_qubits - 1):
                circuit.rzz(2 * J * dt, i, i + 1)  # Full H_{ZZ}

            # Apply the second half of H_X and H_Z (in reverse order)
            for i in range(num_qubits):
                circuit.rx(h * dt, i)  # Second half of H_X
                circuit.rz(g * dt, i)  # Second half of H_Z

    else:
      print('Order must be 1 or 2--fix this!')

    return circuit


# Example usage
num_qubits = 4
circuit = trotterized_time_evolution_circuit(J=1.0, h=0.5, g=0.5, num_qubits=num_qubits, time=1.0, trotter_steps=1, order=0)
circuit.draw('mpl')

from qiskit_aer import QasmSimulator
from qiskit.primitives import StatevectorEstimator
from qiskit.quantum_info import SparsePauliOp
import numpy as np


def compute_magnetization(circuit, num_qubits):
    """
    Computes the magnetization of a given quantum circuit using the Estimator primitive.

    Parameters:
    - circuit: The quantum circuit for which magnetization is computed.
    - num_qubits: The number of qubits in the circuit.

    Returns:
    - Magnetization value as a float.
    """
    # Initialize the Estimator
    estimator = StatevectorEstimator()

    # Define observables for each qubit
    observables = [SparsePauliOp("I" * i + "Z" + "I" * (num_qubits - i - 1)) for i in range(num_qubits)]

    # Compute expectation values for Z on each qubit
    job = estimator.run([(circuit, observables)])

    # Calculate magnetization
    magnetization = np.mean(job.result()[0].data.evs)

    return magnetization

# Example usage
num_qubits = 4
qc = trotterized_time_evolution_circuit(J=1.0, h=0.5, g=0.3, num_qubits=num_qubits, time=1.0, trotter_steps=1, order=1)

# Compute and print magnetization
magnetization = compute_magnetization(qc, num_qubits)
print(f"Magnetization: {magnetization}")

# Sweep over the time
num_qubits = 8
J = 1.0
h = 0.5
g = 0.5
time_list = [i * 0.1 for i in range(10)]
trotter_step_list = [1 for _ in time_list]

magnetization_list = [[], [], []]
first_order_magnetization_list = []
second_order_magnetization_list = []
for time, trotter_step in zip(time_list, trotter_step_list):
  for order in [0, 1, 2]:
    qc = trotterized_time_evolution_circuit(J=J, h=h, g=g, num_qubits=num_qubits, time=time, trotter_steps=trotter_step, order=order)
    magnetization_list[order].append(compute_magnetization(qc, num_qubits))

import matplotlib.pyplot as plt

plt.plot(time_list, magnetization_list[0], label='Exact evolution')
plt.plot(time_list, magnetization_list[1], label='First order Trotterization')
plt.plot(time_list, magnetization_list[2], label='Second order Trotterization')
plt.xlabel('Time')
plt.ylabel('Magnetization')
plt.legend()

