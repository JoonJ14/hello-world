# -*- coding: utf-8 -*-
"""01_Foundations_Challenge.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bjJlyPOw5wjOlnY_NfDGXHax7ASLjzUL
"""

!pip install qiskit
!pip install qiskit_aer
!pip install pylatexenc

import qiskit
import numpy as np

# Step 1: Map the problem to a quantum circuit and operators
from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister

def get_GHZ_circuit_with_phase(num_qubits, theta):
    qc = QuantumCircuit(num_qubits, num_qubits)
    # Apply Hadamard gate to the zeroth qubit
    qc.h(0)
    # Method 1: Rotate the zeroth qubit around the Z-axis that will later
    # create a phase between the all-0 and all-1 states
    qc.p(theta, 0)
    # Apply CNOT gates to entangle the qubits
    for qubit in range(1, num_qubits):
        qc.cx(0, qubit)
    qc.barrier()
    # # Method 2: Rotating each qubit by theta/num_qubits so the total angle is
    # # theta
    # for i in range(num_qubits):
    #     qc.p(theta/num_qubits, i)
    # qc.barrier()
    # Measure in the all-X basis
    for i in range(num_qubits):
        qc.h(i)
    qc.measure_all()
    return qc

# User inputs
min_theta = 0
max_theta = np.pi
num_theta = 10
num_qubits = 8

# Generate the theta list and circuits
theta_list = np.linspace(min_theta, max_theta, num_theta)
circuit_list = [get_GHZ_circuit_with_phase(num_qubits, theta) for theta in theta_list]

circuit_list[1].draw(fold=-1)

# Step 2: Optimize the quantum circuit for a particular backend
# For now, let's just run this circuit on a noiseless simulator
from qiskit_aer import QasmSimulator
from qiskit import transpile

backend = QasmSimulator()
transpiled_circuits_list = transpile(circuit_list, backend)

# Step 3: Execute on quantum hardware
result = backend.run(transpiled_circuits_list, shots=10000).result()

# Step 4: Post-process (and plot)
expectation_values = []

for i in range(num_theta):
    expectation_value = 0
    counts_dict = result.get_counts()[i]
    total_counts = sum(counts_dict.values())
    for outcome, count in counts_dict.items():
        # For the all-X Pauli operator, each qubit contributes +1 if measured in |+> and -1 if in |->
        # Since we measure in the computational basis after applying H, |0> maps to |+> and |1> to |->
        contribution = 1
        for bit in outcome:
            if bit == '1':
                contribution *= -1
        expectation_value += contribution * count
    expectation_value /= total_counts
    expectation_values.append(expectation_value)

import matplotlib.pyplot as plt

plt.plot(theta_list, expectation_values, '-o')
xticks = np.arange(0, 5*np.pi/4, np.pi/4)
xtick_labels = [f"{i}Ï€/4" for i in range(5)]
plt.xticks(ticks=xticks, labels=xtick_labels)
plt.xlabel('Phase angle (radians)')
plt.ylabel('Expectation value of all-X Pauli operator')
plt.grid(True)
plt.show()