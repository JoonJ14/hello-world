# -*- coding: utf-8 -*-
"""01_B_Foundations_Challenge_Solutions_CHSH.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WhLenDog3D6WSCKvMePMKkB7Wfk-JBw3
"""

!pip install qiskit --quiet
!pip install qiskit_aer --quiet
!pip install pylatexenc --quiet

import qiskit
import numpy as np

from qiskit import QuantumCircuit
from qiskit_aer import QasmSimulator
from qiskit import transpile

"""x ^ y = a XOR b"""

def CHSH_circuit(x, y, theta):
    """
    Creates and returns a quantum circuit for the
    CHSH (Clauser-Horne-Shimony-Holt) test, demonstrating quantum entanglement
    and the violation of Bell's inequality. The circuit, designed for
    two qubits, varies based on inputs `x`, `y`, and the angle `theta`.

    Parameters:
    - x (int): Binary input (0 or 1) determining if the first qubit is measured
    in the (0, 1) or (+, -) Basis. 1 measures in the (+, -),
    0 measures in the (0, 1).
    - y (int): Binary input (0 or 1) determining if the first qubit is measured
    in the (0, 1) or a Basis rotated pi/2 on the Y-Axis. 1 measures in the
    rotated basis, 0 measures in the (0, 1).
    - theta (float): Offset Angle in radians for the measurement basis
    of the second qubit.

    Returns:
    QuantumCircuit: The configured quantum circuit with qubit
    initialization, entanglement, conditional operations, and measurements.

    Example:
    ```python
    from qiskit import QuantumCircuit
    import numpy as np

    # Define the angle for rotation
    theta = np.pi / 4  # 45 degrees

    # Create the CHSH circuit
    qc = CHSH_circuit(x=1, y=0, theta=theta)

    # Print or visualize the circuit
    print(qc)
    ```
    """
    qc = QuantumCircuit(2)
    qc.h(0)
    qc.cx(0, 1)
    # determine whihc basis to measure the first qubit in
    if x == 1:
        qc.h(0)
    else:
        qc.id(0)
    # determine which basis to measure the second qubit in
    if y == 1:
        qc.ry(np.pi/2, 1)
    else:
        qc.id(1)
    # Offset angle to measure teh second qubit in
    qc.ry(theta, 1)

    qc.measure_all()
    return qc

def run_experiment(circuit_list):
  backend = QasmSimulator()
  transpiled_circuits_list = transpile(circuit_list, backend)
  return backend.run(transpiled_circuits_list, shots=1).result()

def get_responses(results):
  keys_list = [list(count.keys()) for count in results.get_counts()]
  A = []
  B = []
  for binary_string in keys_list:
      bit_string = binary_string[0]  # Extract the binary string from the inner list
      B.append(int(bit_string[0]))  # The MSB is always the first character

      # If the string has a second character, use it; otherwise, use '0'
      if len(bit_string) > 1:
          A.append(int(bit_string[1]))
      else:
          A.append(0)

  return A, B

def calculate_chsh_expected_value(inputs_x, inputs_y, outputs_a, outputs_b):
    """
    Calculates the expected value for the CHSH game. The CHSH game rewards 1 point
    whenever the condition (X AND Y) equals (A XOR B) is met. This function computes
    the expected value based on the inputs and outputs provided for multiple rounds
    of the game.

    Parameters:
    - inputs_x (np.array): Input choices for player X, represented as a numpy array.
    - inputs_y (np.array): Input choices for player Y, represented as a numpy array.
    - outputs_a (np.array): Output choices for player A, corresponding to X's inputs.
    - outputs_b (np.array): Output choices for player B, corresponding to Y's inputs.

    Returns:
    - float: The expected value calculated as the fraction of rounds won over the total rounds played.
    """
    # Calculate the condition X AND Y
    condition_xy = np.bitwise_and(inputs_x, inputs_y)

    # Calculate the condition A XOR B
    condition_ab = np.bitwise_xor(outputs_a, outputs_b)

    # Count the number of rounds where (X AND Y) equals (A XOR B)
    successful_rounds = np.sum(condition_xy == condition_ab)

    # Calculate the expected value by normalizing successful rounds by the total number of rounds
    expected_value = successful_rounds / len(inputs_x)

    return expected_value

# User inputs
min_theta = 0
max_theta = 2*np.pi
num_theta = 17
# num_qubits = 8

# Generate the theta list and circuits
theta_list = np.linspace(min_theta, max_theta, num_theta)

expectation_values = []
num_circuits = 1000
for i in range(num_theta):
  expectation_value = 0
  X = np.random.choice([0, 1], num_circuits)
  Y = np.random.choice([0, 1], num_circuits)
  circuit_list = [CHSH_circuit(x, y, theta_list[i]) for (x, y) in zip(X, Y)]
  results = run_experiment(circuit_list)
  # print(results.get_counts())
  A, B = get_responses(results)
  expectation_values.append(calculate_chsh_expected_value(X, Y, A, B))

[(x, y) for (x, y) in zip(expectation_values, theta_list)]

import matplotlib.pyplot as plt

plt.plot(theta_list, expectation_values, '-o')
xticks = np.arange(0, 9*np.pi/4, np.pi/4)
xtick_labels = [f"{i}Ï€/4" for i in range(9)]
plt.xticks(ticks=xticks, labels=xtick_labels)
plt.xlabel('Phase angle (radians)')
plt.ylabel('Expectation value of all-X Pauli operator')
plt.grid(True)
plt.show()

